Functions and methods are fundamental building blocks of software
design. Writing clear, focused, and maintainable functions is crucial
for building reliable and understandable data center software projects.
This chapter outlines best practices to design functions with single
responsibility, clear naming, proper parameter usage, robust error
handling, and correct visibility.

## 5.1 Single Responsibility and Cohesion

Each function or method should have a **single responsibility** --- it
should do one thing and do it well. This concept, part of the Single
Responsibility Principle (SRP), promotes highly cohesive functions where
the logic inside relates to one specific task or purpose.

### Benefits of Single Responsibility:

- Simplifies understanding and debugging.

- Enhances reuse and testing since functions are isolated and
  predictable.

- Reduces risk of unintended side effects from overlapping
  responsibilities.

### Example

Bad:

```python
def process_user(user_data):
    # Validates user data, saves to database, and sends welcome email
    validate(user_data)
    save_to_db(user_data)
    send_email(user_data['email'])
```

Good:

```python
def validate_user(user_data):
    # Validate user input data
    pass

def save_user(user_data):
    # Save user to database
    pass

def send_welcome_email(email):
    # Send welcome email
    pass
```

## 5.2 Naming Functions Clearly

Function names should clearly describe **what** the function does,
preferably with a verb or verb phrase. Avoid vague or overloaded names.

### Guidelines

- Use action verbs: `calculateTotal()`, `fetchReport()`, `validateInput()`.

- Avoid generic names like `handleData()` or `processInfo()`.

- Follow consistent casing style per language conventions (camelCase,
snake_case, PascalCase).

## 5.3 Parameter and Return Value Conventions

- Keep the **number of parameters minimal**; consider grouping related
  parameters into objects or structures.

- Parameters should be named clearly to indicate their role.

- Document expected types, allowed values, and any side effects.

- Functions should have a **single return value** where possible. If
  multiple values are needed, use tuples, objects, or data structures.

### Example (Python)

```python
def calculate_area(width: float, height: float) -> float:
    return width * height
```

## 5.4 Error Handling Strategies

Robust functions anticipate and handle errors gracefully to maintain
system stability and provide useful feedback.

### Common practices:

- Use **exceptions** to handle unexpected or erroneous conditions
  (Java, Python, C++).

- Return special status codes or results indicating success or failure.

- Validate inputs early and raise errors or reject invalid data.

- Log errors at appropriate levels with contextual information.

### Example (Python):

```python
def open_file(file_path):
    try:
        with open(file_path, 'r') as f:
            return f.read()
    except FileNotFoundError:
        print("Error: File not found.")
        return None
```

## 5.5 Example Function Signatures and Formats

| Language | Function Signature Example |
|---|---|
| Python | `def fetch_user(user_id: int) -> dict:` |
| Java | `public User fetchUser(int userId) throws UserNotFoundException { ... }` |
| C++ | `User fetchUser(int userId);` |
| JavaScript | `function fetchUser(userId) { ... }` |

## 5.6 Visibility (Private, Public) and Accessibility Rules

Controlling function accessibility is important for encapsulation and
reducing unintended usage.

- **Public** functions form the interface with other components or
  external clients. They should be stable and well-documented.

- **Private/internal** functions support implementation details and
  should hide complexity. Naming or language-specific keywords often
  indicate private status (e.g., underscore prefix in Python `_helper_func()`,
  `private` keyword in Java/C++).

- Limit exposure of functions to only what is necessary for external use
  to reduce coupling and improve modularity.
