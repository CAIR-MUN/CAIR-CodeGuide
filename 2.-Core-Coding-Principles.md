## 2.1 DRY (Don't Repeat Yourself)

The DRY principle states that "Every piece of knowledge must have a
single, unambiguous, authoritative representation within a system." In
practice, this means avoiding duplication of code, logic, or data. When
repeated code exists, making changes becomes error-prone and
time-consuming as developers must update each duplicate separately.
Adhering to DRY improves maintainability, reduces bugs, and promotes
code reuse.

### Importance

- Centralizes logic for easier updates and consistent behavior.

- Reduces risk of introducing inconsistent changes.

- Simplifies debugging and testing by limiting the number of code
  locations to verify.

### Examples to Avoid

• Copy-pasting validation logic across multiple functions.

• Repeating the same calculation or formatting code instead of creating
reusable functions.

• Duplicating configuration values or constants.

### Best Practices to Achieve DRY

• Use functions or methods for repeated logic.

• Create shared utility libraries or modules.

• Consolidate constants and configuration in one location.

• Apply inheritance or composition for similar class behaviors.

## 2.2 KISS (Keep It Simple, Stupid)

The KISS principle encourages writing code that is as simple as possible
without unnecessary complexity. Complex solutions are harder to
understand, maintain, and modify. Strive for clarity, straightforward
logic, and avoid over-engineering.

### Simplification Strategies

• Break problems into smaller, manageable functions.

• Avoid deep nesting of conditional statements.

• Use descriptive variable and function names.

• Prefer readable code over clever or overly concise constructions.

### Anti-patterns to Avoid

• Premature optimization causing convoluted code.

• Overuse of design patterns where plain code suffices.

• Excessive abstraction leading to difficult-to-trace code.

## 2.3 YAGNI (You Aren't Gonna Need It)

YAGNI warns against adding functionality until it is necessary.
Overbuilding features or generalizing code for hypothetical future needs
leads to wasted effort and unnecessarily complicated codebases.

### Guidance

• Implement only the required features at present.

• Refactor and extend code when actual needs arise.

• Avoid speculative abstractions or optimizations.

## 2.4 SOLID Principles (Overview)

The SOLID principles are a set of object-oriented design guidelines that
promote maintainable, scalable, and robust software.

• S: Single Responsibility Principle: A class/function should have one
and only one reason to change.

• O: Open/Closed Principle: Software entities should be open for
extension, but closed for modification.

• L: Liskov Substitution Principle: Objects should be replaceable by
instances of their subtypes without altering correctness.

• I: Interface Segregation Principle: Many client-specific interfaces
are better than one general-purpose interface.

• D: Dependency Inversion Principle: Depend on abstractions, not on
concrete implementations.

These principles help manage complexity and improve code flexibility,
particularly for large codebases.

## 2.5 OWASP Secure Coding Principles

Security must be integral to coding practices to protect systems and
data from vulnerabilities. The OWASP (Open Web Application Security
Project) provides guidelines and best practices to guide secure
development.

### Security Mindset

• Treat all input as untrusted and validate it rigorously.

• Prefer secure defaults and enforce the principle of least privilege.

• Avoid exposing sensitive information in logs, error messages, or
source code.

• Keep dependencies up-to-date to mitigate known vulnerabilities.

### Common Threat Examples

• Injection Attacks: SQL, command injection by unsanitized inputs.

• Cross-Site Scripting (XSS): Malicious scripts injected into web pages.

• Broken Authentication: Weak login, session management.

• Sensitive Data Exposure: Inadequate encryption or data masking.

Adopting these secure coding principles minimizes the attack surface and
helps build resilient, trusted applications.
