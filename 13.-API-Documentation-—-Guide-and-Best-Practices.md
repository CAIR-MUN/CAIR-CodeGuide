APIs are contracts between services and clients. Good API documentation
reduces integration time and prevents misuse.

## 13.1 What to Document

- Resource endpoints, expected request/response schemas, status codes,
  authentication requirements, and common error responses.
- Examples for common requests and responses.
- Versioning policy and backward-compatibility rules.

## 13.2 Best Tools

- Use OpenAPI/Swagger for REST APIs to provide machine-readable specs
  and interactive docs.
- Use gRPC with proto definitions and generated docs for RPC systems.

## 13.3 Good Examples

- Provide an OpenAPI spec and a short example using `curl`.

```bash
curl -X POST "https://api.example.com/v1/items" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name": "example", "value": 123}'
```

## 13.4 What Not To Do

- Don't rely solely on narrative docs without a machine-readable
  contract â€” clients will drift.
- Avoid publishing incomplete specs. Mark alpha/beta endpoints clearly.
- Don't embed secrets or tokens in documentation examples; use placeholders.

## 13.5 Versioning and Deprecation

- Use semantic versioning for APIs where possible (e.g., `/v1/` path).
- Provide deprecation timelines and automated warnings for clients.

## 13.6 Testing and Validation

- Validate API contracts in CI (OpenAPI validation, contract tests).
- Use example-driven tests to ensure docs match implementation.
