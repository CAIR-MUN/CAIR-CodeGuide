Effective error handling and logging are essential for building
resilient, observable, and maintainable systems. This chapter focuses on
practical patterns and examples developers should follow.

## 8.1 Exception Handling Conventions

- Fail fast: detect and raise errors as soon as a problem is discovered.

- Prefer specific exceptions over generic catches to avoid hiding bugs.

- Validate inputs early and raise clear exceptions with context.

- Use try/except or try/catch blocks only where you can handle or add
  meaningful context â€” otherwise allow errors to bubble to a higher
  level where they can be handled centrally.

- Avoid using exceptions for normal control flow.

- Clean up resources reliably using finally blocks, context managers
  (Python `with`), or language-specific constructs (e.g., try-with-
  resources in Java).

### Example (Python)

```python
def read_config(path):
    try:
        with open(path, 'r') as f:
            return f.read()
    except FileNotFoundError as e:
        raise ConfigurationError(f"Config not found: {path}") from e
```

## 8.2 Logging Levels and Message Standards

- DEBUG: Detailed technical information for debugging.
- INFO: High-level operational events (startup, shutdown, config).
- WARN: Recoverable problems or unexpected states.
- ERROR: Errors that prevent an operation from completing.
- FATAL/CRITICAL: Unrecoverable errors requiring immediate attention.

### Message content

- Include contextual keys (request id, user id, function name) to
  support log correlation.
- Avoid logging secrets or sensitive data.
- Prefer structured logs (JSON) for better parsing and observability.

## 8.3 Structured Logging Example

```json
{
  "timestamp": "2025-11-23T12:00:00Z",
  "level": "ERROR",
  "service": "ingest-service",
  "message": "Failed to process record",
  "record_id": "abc123",
  "error": "ValueError: invalid field"
}
```

## 8.4 Error Classification and Handling Patterns

- Transient vs Permanent errors: retry only transient errors with
  exponential backoff.
- Retry patterns: use idempotent operations when retrying.
- Circuit Breakers: prevent cascading failures by stopping attempts
  when a downstream system is unhealthy.

## 8.5 Observability and Monitoring

- Ensure errors increment counters/metrics and generate alerts for
  high-severity failure trends.
- Capture stack traces for ERROR-level logs to speed root-cause
  analysis.
- Use correlation IDs to trace requests end-to-end across services.

## 8.6 Practical Recommendations

- Centralize logging configuration and formats across services.
- Redact or mask sensitive fields before logging.
- Test error paths and log output as part of CI tests.

